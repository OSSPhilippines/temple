<!DOCTYPE html><html><head><style>
  :host { 
    background-color: #DA532C; 
    color: #EFEFEF; 
    display: block;
    height: 100%;
    margin: 0px;
    padding: 1px;
    width: 100%;
  }
  img { width: 100px; height: 100px; }
  .title { text-align: center; }
  .logo { text-align: center; }
  .description { text-align: center; }
  .list { text-align: center; }
</style><script>var TempleBundle = (() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // ../../node_modules/@blanquera/types/dist/Status.js
  var require_Status = __commonJS({
    "../../node_modules/@blanquera/types/dist/Status.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.default = {
        get ABORT() {
          return { code: 308, message: "Aborted" };
        },
        get ERROR() {
          return { code: 500, message: "Internal Error" };
        },
        get NOT_FOUND() {
          return { code: 404, message: "Not Found" };
        },
        get OK() {
          return { code: 200, message: "OK" };
        }
      };
    }
  });

  // ../../node_modules/@blanquera/types/dist/Exception.js
  var require_Exception = __commonJS({
    "../../node_modules/@blanquera/types/dist/Exception.js"(exports) {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      var Exception = class extends Error {
        static for(message, ...values) {
          values.forEach(function(value) {
            message = message.replace("%s", value);
          });
          return new this(message);
        }
        static forErrorsFound(errors) {
          const exception = new this("Invalid Parameters");
          exception.errors = errors;
          return exception;
        }
        static require(condition, message, ...values) {
          if (!condition) {
            for (const value of values) {
              message = message.replace("%s", value);
            }
            throw new this(message);
          }
        }
        constructor(message, code = 500) {
          super();
          this.errors = {};
          this.start = 0;
          this.end = 0;
          this.message = message;
          this.name = this.constructor.name;
          this.code = code;
        }
        withCode(code) {
          this.code = code;
          return this;
        }
        withPosition(start, end) {
          this.start = start;
          this.end = end;
          return this;
        }
        toJSON() {
          return {
            error: true,
            code: this.code,
            message: this.message
          };
        }
      };
      exports.default = Exception;
    }
  });

  // ../../node_modules/@blanquera/types/dist/TaskQueue.js
  var require_TaskQueue = __commonJS({
    "../../node_modules/@blanquera/types/dist/TaskQueue.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Status_1 = __importDefault(require_Status());
      var Exception_1 = __importDefault(require_Exception());
      var TaskQueue = class {
        constructor() {
          this.tasks = [];
          this.lower = 0;
          this.upper = 0;
        }
        get length() {
          return this.tasks.length;
        }
        add(callback, priority = 0) {
          Exception_1.default.require(typeof callback === "function", "Argument 1 expected Function");
          Exception_1.default.require(typeof priority === "number", "Argument 2 expected Number");
          if (priority > this.upper) {
            this.upper = priority;
          } else if (priority < this.lower) {
            this.lower = priority;
          }
          this.tasks.push({ callback, priority });
          this.tasks.sort((a, b) => {
            return a.priority <= b.priority ? 1 : -1;
          });
          return this;
        }
        push(callback) {
          Exception_1.default.require(typeof callback === "function", "Argument 1 expected Function");
          return this.add(callback, this.lower - 1);
        }
        shift(callback) {
          Exception_1.default.require(typeof callback === "function", "Argument 1 expected Function");
          return this.add(callback, this.upper + 1);
        }
        run(...args) {
          return __awaiter(this, void 0, void 0, function* () {
            if (!this.tasks.length) {
              return Status_1.default.NOT_FOUND;
            }
            while (this.tasks.length) {
              const task = this.tasks.shift();
              if (task && (yield task.callback(...args)) === false) {
                return Status_1.default.ABORT;
              }
            }
            return Status_1.default.OK;
          });
        }
        runSync(...args) {
          if (!this.tasks.length) {
            return Status_1.default.NOT_FOUND;
          }
          while (this.tasks.length) {
            const task = this.tasks.shift();
            if (task.callback(...args) === false) {
              return Status_1.default.ABORT;
            }
          }
          return Status_1.default.OK;
        }
      };
      exports.default = TaskQueue;
    }
  });

  // ../../node_modules/@blanquera/types/dist/EventEmitter.js
  var require_EventEmitter = __commonJS({
    "../../node_modules/@blanquera/types/dist/EventEmitter.js"(exports) {
      "use strict";
      var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Status_1 = __importDefault(require_Status());
      var TaskQueue_1 = __importDefault(require_TaskQueue());
      var Exception_1 = __importDefault(require_Exception());
      var EventEmitter = class _EventEmitter {
        constructor() {
          this.listeners = {};
          this.event = {
            event: "idle",
            pattern: "idle",
            parameters: []
          };
          this.regexp = [];
        }
        static makeQueue() {
          return new TaskQueue_1.default();
        }
        emit(event, ...args) {
          return __awaiter(this, void 0, void 0, function* () {
            Exception_1.default.require(typeof event === "string", "Argument 1 expected String");
            const matches = this.match(event);
            if (!Object.keys(matches).length) {
              return Status_1.default.NOT_FOUND;
            }
            const queue = _EventEmitter.makeQueue();
            Object.keys(matches).forEach((key) => {
              const match = matches[key];
              const event2 = match.pattern;
              if (typeof this.listeners[event2] === "undefined") {
                return;
              }
              match.args = args;
              this.listeners[event2].forEach((listener) => {
                queue.add((...args2) => __awaiter(this, void 0, void 0, function* () {
                  this.event = Object.assign({}, match, listener);
                  return yield listener.callback(...args2);
                }), listener.priority);
              });
            });
            return yield queue.run(...args);
          });
        }
        emitSync(event, ...args) {
          Exception_1.default.require(typeof event === "string", "Argument 1 expected String");
          const matches = this.match(event);
          if (!Object.keys(matches).length) {
            return Status_1.default.NOT_FOUND;
          }
          const queue = _EventEmitter.makeQueue();
          Object.keys(matches).forEach((key) => {
            const match = matches[key];
            const event2 = match.pattern;
            if (typeof this.listeners[event2] === "undefined") {
              return;
            }
            match.args = args;
            this.listeners[event2].forEach((listener) => {
              queue.add((...args2) => {
                this.event = Object.assign({}, match, listener);
                return listener.callback(...args2);
              }, listener.priority);
            });
          });
          return queue.runSync(...args);
        }
        inspect(event) {
          Exception_1.default.require(typeof event === "string", "Argument 1 expected String");
          const matches = this.match(event);
          if (!Object.keys(matches).length) {
            return [];
          }
          const queue = _EventEmitter.makeQueue();
          Object.keys(matches).forEach((key) => {
            const event2 = matches[key].pattern;
            if (typeof this.listeners[event2] === "undefined") {
              return;
            }
            this.listeners[event2].forEach((listener) => {
              queue.add(listener.callback, listener.priority);
            });
          });
          return queue.tasks;
        }
        match(event) {
          Exception_1.default.require(typeof event === "string", "Argument 1 expected String");
          const matches = {};
          if (typeof this.listeners[event] !== "undefined") {
            matches[event] = {
              event,
              pattern: event,
              parameters: []
            };
          }
          this.regexp.forEach((pattern) => {
            const regexp = new RegExp(pattern.substr(pattern.indexOf("/") + 1, pattern.lastIndexOf("/") - 1), pattern.substr(pattern.lastIndexOf("/") + 1));
            let match, parameters;
            if (regexp.flags.indexOf("g") === -1) {
              match = event.match(regexp);
              if (!match || !match.length) {
                return;
              }
              parameters = [];
              if (Array.isArray(match)) {
                parameters = match.slice();
                parameters.shift();
              }
            } else {
              match = Array.from(event.matchAll(regexp));
              if (!Array.isArray(match[0]) || !match[0].length) {
                return;
              }
              parameters = match[0].slice();
              parameters.shift();
            }
            matches[pattern] = { event, pattern, parameters };
          });
          return matches;
        }
        on(event, callback, priority = 0) {
          Exception_1.default.require(typeof event === "string" || Array.isArray(event) || event instanceof RegExp, "Argument 1 expected String|RegExp (String|RegExp)[]");
          Exception_1.default.require(typeof callback === "function", "Argument 2 expected Function");
          Exception_1.default.require(typeof priority === "number", "Argument 3 expected Number");
          if (Array.isArray(event)) {
            event.forEach((event2) => {
              this.on(event2, callback, priority);
            });
            return this;
          }
          if (event instanceof RegExp) {
            event = event.toString();
            if (this.regexp.indexOf(event) === -1) {
              this.regexp.push(event);
            }
          }
          if (typeof this.listeners[event] === "undefined") {
            this.listeners[event] = [];
          }
          this.listeners[event].push({ priority, callback });
          return this;
        }
        unbind(event, callback) {
          if (!event && !callback) {
            for (let key in this.listeners) {
              delete this.listeners[key];
            }
            return this;
          }
          const listener = this.listeners[event];
          if (!callback && typeof listener !== "undefined") {
            delete this.listeners[event];
            return this;
          }
          if (typeof listener !== "undefined" && typeof callback === "function") {
            listener.forEach((task, i) => {
              if (callback === task.callback) {
                listener.splice(i, 1);
                if (!listener.length) {
                  delete this.listeners[event];
                }
              }
            });
          }
          if (!event && typeof callback === "function") {
            Object.keys(this.listeners).forEach((event2) => {
              this.listeners[event2].forEach((listener2, i) => {
                if (callback === listener2.callback) {
                  this.listeners[event2].splice(i, 1);
                  if (!this.listeners[event2].length) {
                    delete this.listeners[event2];
                  }
                }
              });
            });
          }
          return this;
        }
        use(...emitters) {
          for (let i = 0; i < emitters.length; i++) {
            const emitter = emitters[i];
            this.regexp = this.regexp.concat(emitter.regexp);
            this.regexp = this.regexp.filter((v, i2, a) => a.indexOf(v) === i2);
            for (const event in emitter.listeners) {
              const tasks = emitter.listeners[event];
              for (let j = 0; j < tasks.length; j++) {
                this.on(event, tasks[j].callback, tasks[j].priority);
              }
            }
          }
          return this;
        }
      };
      exports.default = EventEmitter;
    }
  });

  // ../temple-client/dist/TempleEmitter.js
  var require_TempleEmitter = __commonJS({
    "../temple-client/dist/TempleEmitter.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TempleEmitter = void 0;
      var EventEmitter_1 = __importDefault(require_EventEmitter());
      var TempleEmitter = class extends EventEmitter_1.default {
        on(event, callback, priority = 0) {
          if (event === "ready") {
            const next = callback;
            if (document.readyState === "complete" || document.readyState === "interactive") {
              setTimeout(next, 1);
            } else {
              document.addEventListener("DOMContentLoaded", () => next());
            }
            return this;
          }
          return super.on(event, callback, priority);
        }
      };
      exports.TempleEmitter = TempleEmitter;
      var emitter = new TempleEmitter();
      exports.default = emitter;
    }
  });

  // ../temple-client/dist/TempleElement.js
  var require_TempleElement = __commonJS({
    "../temple-client/dist/TempleElement.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var TempleEmitter_1 = __importDefault(require_TempleEmitter());
      var TempleElement6 = class _TempleElement {
        static create(name, attributes, children = []) {
          const element = document.createElement(name);
          for (const [key, value] of Object.entries(attributes)) {
            if (typeof value === "string" && key !== "children") {
              element.setAttribute(key, value);
            }
          }
          children.forEach((child) => element.appendChild(child));
          return this.register(element, attributes);
        }
        static filter(callback) {
          const elements = [];
          this.registry.forEach((temple, html) => {
            if (callback(temple, html)) {
              elements.push(temple);
            }
          });
          return elements;
        }
        static get(element) {
          return this.registry.get(element) || null;
        }
        static localize(definition, attributes, children = []) {
          const tagname = definition.component[0];
          const template = document.createElement("template");
          template.innerHTML = `<x-${tagname}></x-${tagname}>`;
          const fragment = template.content;
          const component = fragment.querySelector(`x-${tagname}`);
          Object.setPrototypeOf(component, definition.prototype);
          component.constructor = definition.constructor;
          component.constructor.component = definition.component;
          for (const [key, value] of Object.entries(attributes)) {
            if (typeof value === "string" && key !== "children") {
              component.setAttribute(key, value);
            }
          }
          children.forEach((child) => component.appendChild(child));
          const element = this.register(component, attributes);
          component.wait();
          return element;
        }
        static map(callback) {
          const elements = [];
          this.registry.forEach((temple, html) => {
            elements.push(callback(temple, html));
          });
          return elements;
        }
        static register(element, attributes) {
          if (this.registry.has(element)) {
            return this.get(element);
          }
          return new _TempleElement(element, attributes || {});
        }
        get attributes() {
          return Object.assign({}, this._attributes);
        }
        get element() {
          return this._element;
        }
        constructor(element, attributes) {
          this._element = element;
          this._attributes = attributes;
          _TempleElement.registry.set(this._element, this);
        }
        hasAttribute(key) {
          return key in this._attributes;
        }
        getAttribute(key) {
          return this._attributes[key];
        }
        removeAttribute(key, silent = false) {
          const current = this.getAttribute(key);
          if (typeof current === "undefined") {
            return this;
          }
          delete this._attributes[key];
          this._element.removeAttribute(key);
          if (!silent) {
            TempleEmitter_1.default.emit("attribute-remove", this, key, current);
          }
          return this;
        }
        serialize(attributes) {
          if (!attributes) {
            attributes = this._attributes;
          }
          return JSON.stringify(attributes, (name, value) => {
            if (typeof value === "function") {
              return value.toString();
            }
            return value;
          });
        }
        setAttribute(key, value, silent = false) {
          if (typeof value === "undefined") {
            return this.removeAttribute(key, silent);
          }
          const current = this.getAttribute(key);
          if (current === value) {
            return this;
          }
          this._attributes[key] = value;
          if (typeof value === "string" && key !== "children") {
            this._element.setAttribute(key, value);
          }
          if (!silent) {
            if (typeof current === "undefined") {
              TempleEmitter_1.default.emit("attribute-create", this, key, value);
            } else {
              TempleEmitter_1.default.emit("attribute-update", this, key, value, current);
            }
          }
          return this;
        }
        setAttributes(attributes, silent = false) {
          for (const [key, value] of Object.entries(attributes)) {
            this.setAttribute(key, value, silent);
          }
          const names = Object.keys(attributes);
          for (const key of Object.keys(this._attributes)) {
            if (!names.includes(key)) {
              this.removeAttribute(key, silent);
            }
          }
          return this;
        }
      };
      TempleElement6.registry = /* @__PURE__ */ new Map();
      exports.default = TempleElement6;
    }
  });

  // ../temple-client/dist/TempleException.js
  var require_TempleException = __commonJS({
    "../temple-client/dist/TempleException.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var Exception_1 = __importDefault(require_Exception());
      var TempleException = class extends Exception_1.default {
      };
      exports.default = TempleException;
    }
  });

  // ../temple-client/dist/TempleComponent.js
  var require_TempleComponent = __commonJS({
    "../temple-client/dist/TempleComponent.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var TempleElement_1 = __importDefault(require_TempleElement());
      var TempleEmitter_1 = __importDefault(require_TempleEmitter());
      var ServerProps = window.__SERVER_PROPS__;
      var TempleComponent6 = class _TempleComponent extends HTMLElement {
        static get current() {
          return _TempleComponent._current;
        }
        get element() {
          return TempleElement_1.default.get(this);
        }
        get props() {
          return Object.assign({}, this.element.attributes);
        }
        get initiated() {
          return this._initiated;
        }
        set props(props6) {
          if (this.element.serialize(props6) === this.element.serialize()) {
            return;
          }
          const properties = Object.assign({}, props6);
          for (const [name, value] of Object.entries(props6)) {
            if (typeof value === "string") {
              if (value.startsWith("data:")) {
                let decoded = value.substring(5);
                if (value === "true") {
                  decoded = true;
                } else if (value === "false") {
                  decoded = false;
                } else if (value === "null") {
                  decoded = null;
                }
                properties[name] = decoded;
              } else if (value.startsWith("prop:")) {
                const key = value.substring(5);
                if (typeof ServerProps[key] !== "undefined") {
                  properties[name] = ServerProps[key];
                }
              }
            }
          }
          this.element.setAttributes(properties);
          this.render();
        }
        constructor() {
          super();
          this._initiated = false;
          this._template = null;
          this._children = void 0;
          TempleElement_1.default.register(this);
        }
        adoptedCallback() {
          this.render();
        }
        attributeChangedCallback(name, previous, value) {
          this.props = Object.assign(Object.assign({}, this.props), { [name]: value });
        }
        connectedCallback() {
          this.wait();
        }
        disconnectedCallback() {
        }
        render() {
          _TempleComponent._current = this;
          const styles = this.styles();
          if (!this._template) {
            this._template = this.template();
          }
          const children = this._template().filter(Boolean);
          if (styles.length === 0) {
            this.textContent = "";
            children.forEach((child) => this.appendChild(child));
          } else {
            if (!this.shadowRoot) {
              this.attachShadow({ mode: "open" });
            }
            const shadowRoot = this.shadowRoot;
            this.textContent = "";
            shadowRoot.textContent = "";
            const style = document.createElement("style");
            style.innerText = styles;
            shadowRoot.appendChild(style);
            children.forEach((child) => {
              var _a;
              return (_a = this.shadowRoot) === null || _a === void 0 ? void 0 : _a.appendChild(child);
            });
          }
          _TempleComponent._current = null;
          this._initiated = true;
          TempleEmitter_1.default.emit("render", this);
          return this.innerHTML;
        }
        wait() {
          if (this.ready()) {
            this.update(this.innerHTML);
          } else {
            const mutationObserver = new MutationObserver(() => {
              if (this.ready()) {
                this.update(this.innerHTML);
                mutationObserver.disconnect();
              }
            });
            mutationObserver.observe(document.body, { childList: true });
          }
        }
        ready() {
          const parents = [];
          let el = this;
          while (el.parentNode) {
            el = el.parentNode;
            parents.push(el);
          }
          return [this, ...parents].some((element) => element.nextSibling) || document.readyState !== "loading";
        }
        update(children) {
          const entries = Object.fromEntries(Array.from(this.attributes).map((attribute) => [attribute.nodeName, attribute.nodeValue]));
          if (typeof this._children === "undefined") {
            this._children = children;
          }
          this.props = Object.assign(Object.assign(Object.assign({}, this.props), entries), { children: this._children });
          if (!this.initiated) {
            this.render();
          }
        }
      };
      TempleComponent6._current = null;
      exports.default = TempleComponent6;
    }
  });

  // ../temple-client/dist/TempleHelpers.js
  var require_TempleHelpers = __commonJS({
    "../temple-client/dist/TempleHelpers.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bindAttribute = void 0;
      var TempleElement_1 = __importDefault(require_TempleElement());
      var TempleEmitter_1 = __importDefault(require_TempleEmitter());
      function bindAttribute(name, bind) {
        TempleEmitter_1.default.on("ready", () => {
          TempleElement_1.default.filter((temple) => temple.hasAttribute(name)).forEach(bind);
        });
        TempleEmitter_1.default.on("render", (element) => {
          const shadowRoot = element.shadowRoot;
          if (shadowRoot) {
            Array.from(shadowRoot.querySelectorAll("*")).forEach((element2) => {
              const node = TempleElement_1.default.get(element2);
              if (node && node.hasAttribute(name))
                bind(node);
            });
          } else {
            Array.from(element.querySelectorAll("*")).forEach((element2) => {
              const node = TempleElement_1.default.get(element2);
              if (node && node.hasAttribute(name))
                bind(node);
            });
          }
        });
      }
      exports.bindAttribute = bindAttribute;
      bindAttribute("if", (element) => {
        const condition = element.getAttribute("if");
        if (condition === false || condition === "false") {
          element.element.remove();
        } else if (typeof condition === "function" && !condition()) {
          element.element.remove();
        }
      });
      [
        "click",
        "dblclick",
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseover",
        "mouseout",
        "wheel",
        "keydown",
        "keypress",
        "keyup",
        "blur",
        "change",
        "contextmenu",
        "focus",
        "input",
        "submit",
        "invalid",
        "reset",
        "search",
        "select",
        "copy",
        "cut",
        "paste",
        "drag",
        "dragstart",
        "dragend",
        "dragover",
        "dragenter",
        "dragleave",
        "drop",
        "scroll",
        "durationchange",
        "ended",
        "error",
        "loadeddata",
        "loadedmetadata",
        "loadstart",
        "pause",
        "play",
        "playing",
        "progress",
        "ratechange",
        "seeked",
        "seeking",
        "stalled",
        "suspend",
        "timeupdate",
        "volumechange",
        "waiting",
        "animationstart",
        "animationend",
        "animationiteration",
        "transitionend",
        "toggle"
      ].forEach((event) => bindAttribute(event, (element) => {
        const callback = element.getAttribute(event);
        if (typeof callback === "function") {
          element.element.addEventListener(event, callback);
        }
      }));
    }
  });

  // ../temple-client/dist/TempleProps.js
  var require_TempleProps = __commonJS({
    "../temple-client/dist/TempleProps.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      var TempleComponent_1 = __importDefault(require_TempleComponent());
      function props6() {
        if (TempleComponent_1.default.current) {
          return TempleComponent_1.default.current.props;
        }
        return {};
      }
      exports.default = props6;
    }
  });

  // ../temple-client/dist/TempleSignal.js
  var require_TempleSignal = __commonJS({
    "../temple-client/dist/TempleSignal.js"(exports) {
      "use strict";
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignalRegistry = void 0;
      var TempleComponent_1 = __importDefault(require_TempleComponent());
      var TempleException_1 = __importDefault(require_TempleException());
      var SignalRegistry = class _SignalRegistry {
        static observe(component, value) {
          const property = { raw: value };
          Object.defineProperty(property, "value", {
            get() {
              return property.raw;
            },
            set(value2) {
              const rerender = _SignalRegistry.serialize(value2) !== _SignalRegistry.serialize(property.raw);
              property.raw = value2;
              if (rerender) {
                component.render();
              }
            }
          });
          const observer = this.observers.get(component);
          if (!observer) {
            this.observers.set(component, {
              observed: 1,
              values: [property]
            });
          } else {
            observer.observed++;
            observer.values.push(property);
          }
          return property;
        }
        static observer(component) {
          return this.observers.get(component) || null;
        }
        static serialize(value) {
          return JSON.stringify(value);
        }
      };
      exports.SignalRegistry = SignalRegistry;
      SignalRegistry.observers = /* @__PURE__ */ new Map();
      function signal2(value) {
        if (!TempleComponent_1.default.current) {
          throw TempleException_1.default.for("Signals can only be called within a Temple component");
        }
        if (!TempleComponent_1.default.current.initiated) {
          return SignalRegistry.observe(TempleComponent_1.default.current, value);
        }
        const observer = SignalRegistry.observer(TempleComponent_1.default.current);
        if (!observer) {
          throw TempleException_1.default.for("State mismatch");
        }
        return observer.values[observer.observed++ % observer.values.length];
      }
      exports.default = signal2;
    }
  });

  // ../temple-client/dist/index.js
  var require_dist = __commonJS({
    "../temple-client/dist/index.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
      } : function(o, v) {
        o["default"] = v;
      });
      var __importStar = exports && exports.__importStar || function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
        }
        __setModuleDefault(result, mod);
        return result;
      };
      var __importDefault = exports && exports.__importDefault || function(mod) {
        return mod && mod.__esModule ? mod : { "default": mod };
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TempleComponent = exports.SignalRegistry = exports.TempleException = exports.TempleEmitter = exports.TempleElement = exports.signal = exports.props = void 0;
      var TempleElement_1 = __importDefault(require_TempleElement());
      exports.TempleElement = TempleElement_1.default;
      var TempleEmitter_1 = __importDefault(require_TempleEmitter());
      exports.TempleEmitter = TempleEmitter_1.default;
      var TempleException_1 = __importDefault(require_TempleException());
      exports.TempleException = TempleException_1.default;
      var TempleComponent_1 = __importDefault(require_TempleComponent());
      exports.TempleComponent = TempleComponent_1.default;
      require_TempleHelpers();
      var TempleProps_1 = __importDefault(require_TempleProps());
      exports.props = TempleProps_1.default;
      var TempleSignal_1 = __importStar(require_TempleSignal());
      exports.signal = TempleSignal_1.default;
      Object.defineProperty(exports, "SignalRegistry", { enumerable: true, get: function() {
        return TempleSignal_1.SignalRegistry;
      } });
    }
  });

  // ../temple-client/index.js
  var require_temple_client = __commonJS({
    "../temple-client/index.js"(exports, module) {
      module.exports = {
        ...require_dist()
      };
    }
  });

  // ../temple/dist/client.js
  var require_client = __commonJS({
    "../temple/dist/client.js"(exports) {
      "use strict";
      var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        var desc = Object.getOwnPropertyDescriptor(m, k);
        if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
          desc = { enumerable: true, get: function() {
            return m[k];
          } };
        }
        Object.defineProperty(o, k2, desc);
      } : function(o, m, k, k2) {
        if (k2 === void 0) k2 = k;
        o[k2] = m[k];
      });
      var __exportStar = exports && exports.__exportStar || function(m, exports2) {
        for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
      };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(require_temple_client(), exports);
    }
  });

  // ../temple/index.js
  var require_temple = __commonJS({
    "../temple/index.js"(exports, module) {
      module.exports = {
        ...require_client()
      };
    }
  });

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/Header_30f98e79c1c79cd6f0e0.ts
  var import_temple_client = __toESM(require_temple_client());
  var import_temple = __toESM(require_temple());
  var Header = class extends import_temple_client.TempleComponent {
    static component = ["header", "Header"];
    styles() {
      return `:host h1 { 
    font-size: 21px; 
    font-weight: bold;
    text-transform: uppercase;
  }`;
    }
    template() {
      const { className, children } = (0, import_temple.props)();
      return () => [
        import_temple_client.TempleElement.create("h1", { "class": className }, [
          document.createTextNode(String(children))
        ]).element
      ];
    }
  };
  customElements.define("x-header", Header);

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/Paragraph_4054a85433e9724f9be0.ts
  var import_temple_client2 = __toESM(require_temple_client());
  var import_temple2 = __toESM(require_temple());
  var Paragraph = class extends import_temple_client2.TempleComponent {
    static component = ["paragraph", "Paragraph"];
    styles() {
      return ``;
    }
    template() {
      const { classname, children } = (0, import_temple2.props)();
      return () => [
        import_temple_client2.TempleElement.create("p", { "class": classname }, [
          document.createTextNode(String(children))
        ]).element
      ];
    }
  };
  customElements.define("x-paragraph", Paragraph);

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/Todo_c122bb6fd6c8c21756a8.ts
  var import_temple_client5 = __toESM(require_temple_client());

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/Add_5de28b81f46dc2762bf6.ts
  var import_temple_client3 = __toESM(require_temple_client());
  var import_temple3 = __toESM(require_temple());
  var Add = class extends import_temple_client3.TempleComponent {
    static component = ["add", "Add"];
    styles() {
      return `button {
    background-color: #EFEFEF;
    border: none;
    border-radius: 0;
    color: #DA532C;
    cursor: pointer;
    font-weight: semibold;
    padding: 10px 20px;
    text-transform: uppercase;
  }
  .total {
    font-size: 12px;
    margin-top: 20px;
    text-align: center;
    text-transform: uppercase;
  }`;
    }
    template() {
      const { count, list } = (0, import_temple3.props)();
      const add = () => count.value++;
      return () => [
        ...!!(count.value > 0) ? [
          document.createTextNode(`
  `),
          import_temple_client3.TempleElement.create("div", { "class": `total` }, [
            document.createTextNode(`
    Total Tasks: `),
            import_temple_client3.TempleElement.create("strong", {}, [
              document.createTextNode(String(count.value))
            ]).element,
            document.createTextNode(`
  `)
          ]).element,
          document.createTextNode(`
`)
        ] : [],
        document.createTextNode(`

`),
        ...!!(count.value < list.length) ? [
          document.createTextNode(`
  `),
          import_temple_client3.TempleElement.create("button", { "click": add }, [
            document.createTextNode(`Add TODO`)
          ]).element,
          document.createTextNode(`
`)
        ] : []
      ];
    }
  };

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/List_58a66cafb1a13684706c.ts
  var import_temple_client4 = __toESM(require_temple_client());
  var import_temple4 = __toESM(require_temple());
  var List = class extends import_temple_client4.TempleComponent {
    static component = ["list", "List"];
    styles() {
      return `:host {
    width: 100%;
  }
  :host section {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
    padding: 20px;
    border: 1px solid #EFEFEF;
    border-radius: 5px;
    background-color: #DA532C;
    color: #EFEFEF;
  }
  :host ul {
    list-style: none;
    margin: 0 0 20px;
    padding: 10px;
    text-align: center;
  }

  :host li {
    background-color: #DA532C;
    border-radius: 5px;
    margin-bottom: 10px;
    padding: 10px;
  }

  :host li:last-child {
    margin-bottom: 0;
  }`;
    }
    template() {
      const { list } = (0, import_temple4.props)();
      return () => [
        ...!!(list.length > 0) ? [
          document.createTextNode(`
  `),
          import_temple_client4.TempleElement.create("ul", {}, [
            document.createTextNode(`
    `),
            ...Object.entries(list).map(([_, item]) => [
              document.createTextNode(`
      `),
              import_temple_client4.TempleElement.create("li", {}, [
                document.createTextNode(String(item))
              ]).element,
              document.createTextNode(`
    `)
            ]).flat(),
            document.createTextNode(`
  `)
          ]).element,
          document.createTextNode(`
`)
        ] : []
      ];
    }
  };

  // temple-vfs:/Users/cblanquera/server/projects/blanquera/temple/packages/temple-web/src/.temple/51bc8bc28b29cf36cf8c/components/Todo_c122bb6fd6c8c21756a8.ts
  var import_temple5 = __toESM(require_temple());
  var Todo = class extends import_temple_client5.TempleComponent {
    static component = ["todo", "Todo"];
    styles() {
      return `:host section {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    margin: 0 auto;
    padding: 20px 0;
    border: 1px solid #EFEFEF;
    border-radius: 5px;
    background-color: #E49F1A;
    color: #EFEFEF;
    max-width: 400px;
  }`;
    }
    template() {
      const { list, start } = (0, import_temple5.props)();
      const count = (0, import_temple5.signal)(start);
      return () => [
        import_temple_client5.TempleElement.create("section", {}, [
          document.createTextNode(`
  `),
          import_temple_client5.TempleElement.localize(List, { "list": list.slice(0, count.value) }).element,
          document.createTextNode(`
  `),
          import_temple_client5.TempleElement.localize(Add, { "list": list, "count": count }).element,
          document.createTextNode(`
`)
        ]).element
      ];
    }
  };
  customElements.define("x-todo", Todo);
})();
</script><script>;Array.from(document.head.getElementsByTagName("script")).forEach(s => s.remove());</script></head><body><x-header class="title">${title}</x-header>
<div class="logo">
  <img src="/temple-logo.png" alt="Logo" />
</div>
<x-paragraph classname="description">${description}</x-paragraph>
<x-todo list="prop:list" start="prop:start"></x-todo></body></html>